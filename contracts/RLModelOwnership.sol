// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title RLModelOwnership
 * @dev Represents ownership of individual RL models in the Gensyn RL Swarm
 */
contract RLModelOwnership is ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    // Model performance metrics
    struct ModelMetrics {
        uint256 rewardRate;        // Average rewards per episode
        uint256 completionRate;    // Percentage of successful completions
        uint256 lastUpdateBlock;   // Block number of last update
        uint256 contributionScore; // Contribution to swarm performance
    }
    
    // Profit sharing configuration
    struct ProfitConfig {
        address payable[] beneficiaries;  // List of addresses that receive profits
        uint256[] shares;                 // Corresponding shares (must sum to 100)
    }
    
    // Mapping from token ID to model metrics
    mapping(uint256 => ModelMetrics) public modelMetrics;
    
    // Mapping from token ID to profit configuration
    mapping(uint256 => ProfitConfig) public profitConfigs;
    
    // Total profits generated by each model
    mapping(uint256 => uint256) public modelProfits;
    
    // Events
    event ModelMinted(uint256 indexed tokenId, address owner, string uri);
    event MetricsUpdated(uint256 indexed tokenId, uint256 rewardRate, uint256 completionRate, uint256 contributionScore);
    event ProfitsDistributed(uint256 indexed tokenId, uint256 amount);
    
    constructor() ERC721("RL Swarm Model Ownership", "RLMODEL") {}
    
    /**
     * @dev Creates a new Model NFT
     * @param recipient The address that will own the model
     * @param tokenURI The metadata URI for the model
     * @return The ID of the newly minted token
     */
    function mintModel(
        address recipient,
        string memory tokenURI
    ) public returns (uint256) {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        _mint(recipient, newTokenId);
        _setTokenURI(newTokenId, tokenURI);
        
        // Initialize metrics
        modelMetrics[newTokenId] = ModelMetrics({
            rewardRate: 0,
            completionRate: 0,
            lastUpdateBlock: block.number,
            contributionScore: 0
        });
        
        emit ModelMinted(newTokenId, recipient, tokenURI);
        return newTokenId;
    }
    
    /**
     * @dev Updates the performance metrics of a model
     * @param tokenId The ID of the model token
     * @param rewardRate New reward rate
     * @param completionRate New completion rate
     * @param contributionScore New contribution score
     */
    function updateMetrics(
        uint256 tokenId,
        uint256 rewardRate,
        uint256 completionRate,
        uint256 contributionScore
    ) public {
        require(_exists(tokenId), "Model does not exist");
        require(ownerOf(tokenId) == msg.sender || owner() == msg.sender, "Not authorized");
        
        modelMetrics[tokenId].rewardRate = rewardRate;
        modelMetrics[tokenId].completionRate = completionRate;
        modelMetrics[tokenId].contributionScore = contributionScore;
        modelMetrics[tokenId].lastUpdateBlock = block.number;
        
        emit MetricsUpdated(tokenId, rewardRate, completionRate, contributionScore);
    }
    
    /**
     * @dev Sets the profit sharing configuration for a model
     * @param tokenId The ID of the model token
     * @param beneficiaries Array of addresses to receive profits
     * @param shares Array of shares for each beneficiary (must sum to 100)
     */
    function setProfitConfig(
        uint256 tokenId, 
        address payable[] memory beneficiaries,
        uint256[] memory shares
    ) public {
        require(_exists(tokenId), "Model does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        require(beneficiaries.length == shares.length, "Arrays must be same length");
        
        uint256 totalShares = 0;
        for (uint256 i = 0; i < shares.length; i++) {
            totalShares += shares[i];
        }
        require(totalShares == 100, "Shares must sum to 100");
        
        profitConfigs[tokenId].beneficiaries = beneficiaries;
        profitConfigs[tokenId].shares = shares;
    }
    
    /**
     * @dev Distributes profits to a model based on its usage
     * @param tokenId The ID of the model token
     */
    function distributeProfits(uint256 tokenId) public payable {
        require(_exists(tokenId), "Model does not exist");
        require(msg.value > 0, "Must send ETH to distribute");
        
        modelProfits[tokenId] += msg.value;
        
        // If profit config exists, distribute according to shares
        if (profitConfigs[tokenId].beneficiaries.length > 0) {
            ProfitConfig memory config = profitConfigs[tokenId];
            
            for (uint256 i = 0; i < config.beneficiaries.length; i++) {
                uint256 amount = (msg.value * config.shares[i]) / 100;
                config.beneficiaries[i].transfer(amount);
            }
            
            emit ProfitsDistributed(tokenId, msg.value);
        } else {
            // If no profit config, send to token owner
            payable(ownerOf(tokenId)).transfer(msg.value);
            emit ProfitsDistributed(tokenId, msg.value);
        }
    }
    
    /**
     * @dev Get the current metrics for a model
     * @param tokenId The ID of the model token
     * @return Struct containing all metrics
     */
    function getModelMetrics(uint256 tokenId) public view returns (ModelMetrics memory) {
        require(_exists(tokenId), "Model does not exist");
        return modelMetrics[tokenId];
    }
    
    /**
     * @dev Get total accumulated profits for a model
     * @param tokenId The ID of the model token
     * @return Total profits in wei
     */
    function getTotalProfits(uint256 tokenId) public view returns (uint256) {
        require(_exists(tokenId), "Model does not exist");
        return modelProfits[tokenId];
    }
}